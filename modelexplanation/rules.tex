\section{Production Rules}
\subsection{Retrieving Syntactic Information}
There are two relevant production rules to begin processing: GrabWord and AddLexSyn. GrabWord is the simple process of retrieving syntactic information about a word in the input. It can fire at any time the retrieval buffer is not busy. This takes a word from the input and makes a retrieval request for a Lexsyn with that word. AddLexSyn then updates the goal state and does cleanup, by removing the word from input and adding the lexsyn to the goal buffer. This presently allows for an infinite working memory span, though the model in principle could work the same by having a fixed working memory span. As of now, however, this could possibly lead to retrieving a set of lexsyns where none could be combined. Both GrabWord and Lexsyn have as many variants as there are maximum number of words in a sentence. 

\subsection{Syntactic Rules and Resolutions}
Each Syntactic rule is defined many times, requiring dependencies in the Sentence chunk to be met. Mostly, this is by checking if any Lexsyns in the sentence chunk are matches for each other's dependencies. If it is a match, a retrieval request is put out for the matching type. This sets up another type of production rule to follow where the rule is resolved. This updates the type that's stored in chunk, removes the chunk that's been absorbed (in Composition, for no particular reason, the left always absorbs the right), and removes all other possible types of the new chunk, if they still exist. In other words, on the first combination, each Lexsyn contains multiple types, but after it's been combined and forms a type that's not specific to that word, the other types are removed as they are non-equivalent. The syntactic rules in CCG are described below. 

\subsubsection{Forward Application}
Forward Application is a simple combinatory rule where a single dependency of a compound type is resolved to the right (in other words, the type has the Slash combinatory operator). The type resolving the dependency can be a simple type or a compound type. 
\subsubsection{Backward Application}
Backward Application is a simple combinatory rule where a single dependency of a compound type is resolved to the left (in other words, the type has the Backslash operator). The type resolving the dependency can be a simple type or a compound type.
\subsubsection{Forward Composition}
Forward Composition takes two compound types with the Slash operator. If one type has a dependency to the right, and the other type's left side resolves that dependency, then that type gains the other type's right side as a new dependency to the right but resolves its current one and adds that word to the right. 
\subsubsection{Backward Composition}
Backward Composition takes two compound types with the Backslash operator. If one type has a dependency to the left, and the other type's right side resolves that dependency, then that type gains the other type's left side as a new dependency to the left but resolves its current one and adds that word to the left.  
\subsubsection{BeginConjunction}
This corresponds to adding a conjunction to a type that could benefit from it. For instance, this would be the process of transforming "walking" to "and walking" or "walking and". 
\subsubsection{FinishConjunction}
This corresponds to adding an equivalent type to the phrase that contains the conjunction. In other words, it's the processing of transforming "and walking" to "talking and walking" or "walking and" to "walking and talking".
