\section{Chunks and Buffers in the Model}
Our model relies on a fairly simple set of chunks. 

\subsection{Word}
A word is the simplest type. It just has a name, which is the text of the word. It has no slots. The word chunks are built by creating a chunk of each word in the Switchboard corpus.

\subsection{Type}
At the heart of our model are chunks representing CCG syntactic types. There are two basic types of CCG types, though they appear to ACT-R as the same. One is what we refer to as a \textit{simple} type, where the type is a primitive type, such as a noun phrase. There are approximately ten basic CCG types found in the Switchboard data set. The second is a \textit{compound} type, where the type is composed of a left type, a right type, and a \textit{combinatory operator}. The left type and right type of each compound type can be either simple or additional compound types. Type chunks thus have three slots, the FullType, the LeftType, the RightType, and the Combinatory Operator (the last three are null if it is a simple type). Lastly, it has a flag to mark if that type is able to join (via conjunctions) with others of its type. The type chunks are built by creating a type for each type that appears in the Switchboard corpus.

\subsection{Combinatory Operator}
A combinatory operator is a very simple operator that can be thought of as a dependency within a type. As the end-goal of sentence production is to produce a sentence, a complete sentence is always of type \textit{S}, which is one of the CCG simple types. Then, verbs, adjectives, and so on are assigned compound types in such a way that they could ultimately be part of a complete sentence. For instance, an adjective might be NP/N, suggesting that it needs a noun to its right in order to be a noun phrase. If it was NP\textbackslash N, it would instead suggest it needs a noun to its left. Thus, the two combinatory operators are slash and backslash. Combinatory Operator chunks have no slots. These two combinatory operators are predefined.

\subsection{Lexsyn}
A Lexsyn is a Chunk that associates words with their type information. It, simply put, has a slot for the word, and then has the five slots for each type the word can take, where these slots are the exact same as described in the Type chunk. These are built by reading Switchboard, and associating every type (including type-raised types) that any given word ever takes with the word, and then creating the Lexsyn accordingly.  

\subsection{Sentence}
The Sentence is essentially the goal chunk. In this way, it basically contains predefined slots that are the input, and then predefined slots to store the output. Its first several slots is a set of words that are unordered. These are predefined, and consist of the words in a sentence that appears in Switchboard. The Sentence chunk also has several other slots, which correspond basically to lexsyns. Due to the methodology for accessing slots of slots, these are all stored in a flat manner, similarly to how the lexsyn stores types. Thus, the sentence chunk's total number of slots is the maximum number of words in the target sentences multiplied by the maximum number of types any given word has in the target sentences. This makes the chunk quite large. 

The final, correct output for the model is a single Lexsyn with the type S. In general, the output can be thought of as a Lexsyn that contains some number of words and some final syntactic type, where it can no longer combine with any of the other lexsyns. Details on how the Rules utilize the working space in the Sentence chunk will be covered in the next section. 
