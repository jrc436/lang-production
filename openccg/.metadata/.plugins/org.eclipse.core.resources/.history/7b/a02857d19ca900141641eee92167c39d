package ar.xmlparser;

import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LineParser {
	private final String regex;
	private final Pattern p;
	private final NodeHandler nh;
	
	public LineParser(String regex) {
		this.regex = regex;
		this.p = Pattern.compile(regex);
		nh = new NodeHandler();
	}
	//XML 
	public LineParser() {
		this.regex = "^(?<start><[a-z]+(?<attrs> [a-zA-z:0-9]+=\"[a-zA-Z0-9.'_:\\-\\[\\]]+\")*>)?(?<value>[a-zA-Z0-9?':!+`\\$\\-.,]+)?(?<close></[a-z\\-]+>)?$";
		this.p = Pattern.compile(regex);
		nh = new NodeHandler();
	}
	public void parse(String input) throws Exception {
		input.trim();				
		Matcher m = p.matcher(input);
		String start = null;
		String attr = null;
		String value = null;
		String close = null;
		while (m.find()) {
			start = m.group("start"); //
			attr = m.group("attrs");
			value = m.group("value");
			close = m.group("close");
		}
		//we're creating a new node!
		if (start != null) {
			//if attr is null, then start is the "start" expression we actually care about
			//as defined, start contains the open bracket and the closing bracket to not make the group structure too complicated
			if (attr == null) {
				start = start.substring(1, start.length()-1); //this will just pull off the brackets
			}
			else {
				start = start.substring(1, start.length()-1-attr.length()); //this will pull off the brackets and attrs 
			}
			XmlNode readingNode = new XmlNode(start, value);
			if (attr != null) {
				String[] attrs = attr.trim().split(" "); //this should be all matches.
				for (String a : attrs) {
					String[] keyVal = a.trim().split("=");
					readingNode.addAttribute(keyVal[0], keyVal[1]);
				}
			}
			if (close != null) {
				nh.AddOpenNode(readingNode);
			}
			
		}
		//we're closing a node! Note that if start and close are both not null, it will not enter here
		else if (close != null) {
			
		}
		else {
			throw new Exception("I don't think this should ever happen in an ordinary node: " + input);
		}
		
	}
	public boolean getNodeClosed() {
		return nodeClosed;
	}
}
