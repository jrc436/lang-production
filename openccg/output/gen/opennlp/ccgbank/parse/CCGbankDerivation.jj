/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. /home/jrc/actup-production/openccg/output/gen/opennlp/ccgbank/parse/CCGbankDerivation.jj */
/*@egen*/// Grammar to parse all the ccgbank derivations in a given ccgbank file

options {                                                                          
    STATIC=true;
    USER_TOKEN_MANAGER=false;                                                
}

PARSER_BEGIN(CCGbankDerivation)

package opennlp.ccgbank.parse;

import java.util.*;
import org.apache.tools.ant.Task;
//import java.io.*;

public class CCGbankDerivation/*@bgen(jjtree)*/implements CCGbankDerivationTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTCCGbankDerivationState jjtree = new JJTCCGbankDerivationState();

/*@egen*/

    // The java code to operate the node scope hook
    static void jjtreeOpenNodeScope(Node n) {
        ((SimpleNode)n).first_token = getToken(1);
    }

    static void jjtreeCloseNodeScope(Node n) {
        ((SimpleNode)n).last_token = getToken(0);
    }
}

PARSER_END(CCGbankDerivation)


// enter PROPINFO state (for extra Propbank-derived info) on "{"
// nb: this is a workaround for ATOMCAT being perhaps too broadly defined
TOKEN: { <LCURLY: "{">  : PROPINFO }

// return to normal on ">" at end of node
<*> TOKEN: { <RANGLE: ">"> : DEFAULT }

// tokens in PROPINFO state
<PROPINFO> TOKEN: { <COMMA: ","> }
<PROPINFO> TOKEN: { <DOT: "."> }
<PROPINFO> TOKEN: { <COLON: ":"> }
<PROPINFO> TOKEN: { <ALPHNUMHYPH: (["A"-"Z","a"-"z","-","0"-"9"])+> } // for stems and sem roles
<PROPINFO> TOKEN: { <RCURLY: "}"> }
<PROPINFO> TOKEN: { <LSQUARE: "["> }
<PROPINFO> TOKEN: { <RSQUARE: "]"> }


// regular tokens
// mww: ATOMCAT is really too broad, b/c it's used for words too ...
TOKEN:
{
    <ATOMCAT: (["A"-"Z","a"-"z","[","]","-","'",".",",","$","=","0"-"9","_",":","&","%",";","?","#","@","!","`","*"])+>
    |
    <OP: "/" | "\\">
    |
    <SPL: (<ATOMCAT>("\\/")*)+|("\\*")+>
    //The SPL token is for treebank words like "1\/2" or "bassoonist\/pianist\/composer" or "\*" where the middle tokens stand elsewhere for ccg operations. 
    //So the SPL prevents such words from interfering with the tokenization
}

<*> SKIP: { " " | "\t" | "\n" | "\r" }


SimpleNode start():
{/*@bgen(jjtree) start */
  start jjtn000 = new start(null, JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) start */
    try {
/*@egen*/
    // Every file consists of one or more treebank entries
    // Each treebank entry consists of 1 header and 1 or more treenodes or leafnodes
    ( header() ( LOOKAHEAD(2) leafnode() | treenode()) )+/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void header():
{/*@bgen(jjtree) header */
    header jjtn000 = new header(null, JJTHEADER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token t1 = new Token();
    Token t2 = new Token();
    Token t3 = new Token();
    jjtn000.type="Header";
}
{/*@bgen(jjtree) header */
    try {
/*@egen*/
    // Header, eg: ID=wsj_2300.1 PARSER=GOLD NUMPARSE=1
    t1=<ATOMCAT> [t2=<ATOMCAT> t3=<ATOMCAT>]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    {
        jjtn000.header = t1.image + " " + t2.image + " " + t3.image;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


void treenode():
{/*@bgen(jjtree) treenode */
    treenode jjtn000 = new treenode(null, JJTTREENODE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token leftover = new Token();
    Token head = new Token();
    Token dtr = new Token();
    Token lex = new Token();
    Token sense = new Token();
    Token role = new Token();
    jjtn000.type="Treenode";
}
{/*@bgen(jjtree) treenode */
    try {
/*@egen*/
    // Storing the ccgID.  (mww: huh?)
    // Sample Treenode: <T S[dcl] 0 2>
    // With Propbank roles: <T S[dcl] 0 2 {stop.01:ARG0,use.01:ARG0}>
    "(" 
        "<T" // Root of a treenode
    
            // Treenode category specification 
            catSpecRedundant()
    
            (
                // The lookahead traps [conj] feature which follows the catspec
                LOOKAHEAD(3)
                leftover=<ATOMCAT> head=<ATOMCAT> dtr=<ATOMCAT>
                { jjtn000.leftover=leftover.image; }          
                |
                head=<ATOMCAT>
                dtr=<ATOMCAT>
            )
            
            // Headedness, number of dtrs info stored in the SimpleNode data structure
            { jjtn000.head=head.image; jjtn000.dtr=dtr.image; }
    
            // optional propbank info
            // nb: need to use eg <DOT> instead of "." once in PROPINFO lex state 
            [
                "{"
                    lex=<ALPHNUMHYPH> <DOT> sense=<ALPHNUMHYPH> <COLON> role=<ALPHNUMHYPH> 
                    { 
                    	jjtn000.nodeRoles = new ArrayList<SimpleNode.LexSenseRole>(3);
                    	jjtn000.nodeRoles.add(new SimpleNode.LexSenseRole(lex.image, sense.image, role.image));
                	}
                    (
                        <COMMA>
	                    lex=<ALPHNUMHYPH> <DOT> sense=<ALPHNUMHYPH> <COLON> role=<ALPHNUMHYPH> 
	                    { jjtn000.nodeRoles.add(new SimpleNode.LexSenseRole(lex.image, sense.image, role.image)); }
                    )*
                <RCURLY>
            ]
            
        <RANGLE> // closure of one the root of a treenode
        
        // A treenode consists of 1 or more treenodes or leafnodes. 
        ( LOOKAHEAD(2) leafnode() | treenode() )+
            
    ")"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/ // Close of a treenode
}


void leafnode():
{/*@bgen(jjtree) leafnode */
    leafnode jjtn000 = new leafnode(null, JJTLEAFNODE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token t = new Token();
    Token lex = new Token();
    Token sense = new Token();
    Token role = new Token();
    jjtn000.type="Leafnode";
}
{/*@bgen(jjtree) leafnode */
    try {
/*@egen*/
    /* Sample Leafnode structures:
     (<L S/S RB RB No S_42/S_42>)
     (<L . . . . .>)
     (<L (S[dcl]\S[dcl])\NP VBD VBD reported (S[dcl]\S[dcl]_8)\NP_9 {report.01:rel} [ARG1,ARG0]>)
    */
    "(" 
        "<L" 
            // Parsed but Ignored
            catSpecRedundant()
            //((S[b]\NP)/NP)/    mww: huh?
    
            // POS tag stored in a SimpleNode DS
            t=<ATOMCAT> { jjtn000.pos = t.image; }
        
            // The pos tag has been repeated in the ccgbank. 
            // For numerals (null) is an entry. 
            // Hence the optional brackets in the bnf below.
            ( ["("] <ATOMCAT> [")"])
        
            ( t=<ATOMCAT> | t=<SPL> )
            { jjtn000.lex = t.image; }
        
            catSpec()
            
            // optional propbank info
            [
                "{"
                    lex=<ALPHNUMHYPH> <DOT> sense=<ALPHNUMHYPH> <COLON> role=<ALPHNUMHYPH> // role or 'rel'
                    { 
                    	jjtn000.nodeRoles = new ArrayList<SimpleNode.LexSenseRole>(3);
                    	jjtn000.nodeRoles.add(new SimpleNode.LexSenseRole(lex.image, sense.image, role.image));
                	}
                    (
                        <COMMA>
	                    lex=<ALPHNUMHYPH> <DOT> sense=<ALPHNUMHYPH> <COLON> role=<ALPHNUMHYPH> 
	                    { jjtn000.nodeRoles.add(new SimpleNode.LexSenseRole(lex.image, sense.image, role.image)); }
                    )*
                <RCURLY>
            ]
            [
                <LSQUARE>
                    role=<ALPHNUMHYPH> 
                    { 
                    	jjtn000.argRoles = new ArrayList<String>(4);
                    	jjtn000.argRoles.add(role.image);
                	}
                    (
                        <COMMA>
                        role=<ALPHNUMHYPH> 
                        { jjtn000.argRoles.add(role.image); }
                    )*
                <RSQUARE>
            ]
        <RANGLE> //">" 
    ")"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void catSpec():
{/*@bgen(jjtree) catSpec */
  catSpec jjtn000 = new catSpec(null, JJTCATSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ jjtn000.type="complexcat"; }
{/*@bgen(jjtree) catSpec */
    try {
/*@egen*/
    // The result category (atomic or complex)
    ( 
        ( "(" catSpec() ")" [<ATOMCAT>] )  // mww: the extra "atomcat" is really for an index on the complex cat
        |
        atomcat()
    )
        
    // The argument of the function (atomic or complex). 
    // Note: The following could be processed as a separate production "Embedded category" , but this would produce a node of that name. 
    //       To avoid that, the preceding BNF notation has been repeated here. 
    [
        op()
        ( 
            ( "(" catSpec() ")" [<ATOMCAT>] )
            |
            atomcat()
        )
    ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


void catSpecRedundant():
{/*@bgen(jjtree) catSpecRedundant */
  catSpecRedundant jjtn000 = new catSpecRedundant(null, JJTCATSPECREDUNDANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ jjtn000.type="Redundant"; }  
{/*@bgen(jjtree) catSpecRedundant */
    try {
/*@egen*/
    ( 
        ( "(" catSpec() ")" )
        |
        atomcat()
    )
    [
        op()
        ( 
            ( "(" catSpec() ")" )
            |
            atomcat()
        )
    ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


void atomcat():
{/*@bgen(jjtree) atomcat */
  atomcat jjtn000 = new atomcat(null, JJTATOMCAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ jjtn000.type="atomcat"; }
{/*@bgen(jjtree) atomcat */
    try {
/*@egen*/
    <ATOMCAT>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void op():
{/*@bgen(jjtree) op */
  op jjtn000 = new op(null, JJTOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t = new Token(); jjtn000.type="op"; }
{/*@bgen(jjtree) op */
    try {
/*@egen*/
    t=<OP>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtreeCloseNodeScope(jjtn000);
           }
/*@egen*/ { jjtn000.cat=t.image; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


