\section{Model}
\subsection{Chunks and Buffers}
Our model relies on a fairly simple set of chunks. 

\subsubsection{Word}
A word is the simplest type. It just has a name, which is the text of the word. It has no slots. The word chunks are built by creating a chunk of each word in the Switchboard corpus.

\subsubsection{Type}
At the heart of our model are chunks representing CCG syntactic types. There are two basic types of CCG types, though they appear to ACT-R as the same. One is what we refer to as a \textit{simple} type, where the type is a primitive type, such as a noun phrase. There are approximately ten basic CCG types found in the Switchboard data set. The second is a \textit{compound} type, where the type is composed of a left type, a right type, and a \textit{combinatory operator}. The left type and right type of each compound type can be either simple or additional compound types. Type chunks thus have three slots, the FullType, the LeftType, the RightType, and the Combinatory Operator (the last three are null if it is a simple type). Lastly, it has a flag to mark if that type is able to join (via conjunctions) with others of its type. The type chunks are built by creating a type for each type that appears in the Switchboard corpus.

\subsubsection{Combinatory Operator}
A combinatory operator is a very simple operator that can be thought of as a dependency within a type. As the end-goal of sentence production is to produce a sentence, a complete sentence is always of type \textit{S}, which is one of the CCG simple types. Then, verbs, adjectives, and so on are assigned compound types in such a way that they could ultimately be part of a complete sentence. For instance, an adjective might be NP/N, suggesting that it needs a noun to its right in order to be a noun phrase. If it was NP\textbackslash N, it would instead suggest it needs a noun to its left. Thus, the two combinatory operators are slash and backslash. Combinatory Operator chunks have no slots. These two combinatory operators are predefined.

\subsubsection{Lexsyn}
A Lexsyn is a Chunk that associates words with their type information. It, simply put, has a slot for the word, and then has the five slots for each type the word can take, where these slots are the exact same as described in the Type chunk. These are built by reading Switchboard, and associating every type (including type-raised types) that any given word ever takes with the word, and then creating the Lexsyn accordingly.  

\subsubsection{Sentence}
The Sentence is essentially the goal chunk. In this way, it basically contains predefined slots that are the input, and then predefined slots to store the output. Its first several slots is a set of words that are unordered. These are predefined, and consist of the words in a sentence that appears in Switchboard. The Sentence chunk also has several other slots, which correspond basically to lexsyns. Due to the methodology for accessing slots of slots, these are all stored in a flat manner, similarly to how the lexsyn stores types. Thus, the sentence chunk's total number of slots is the maximum number of words in the target sentences multiplied by the maximum number of types any given word has in the target sentences. This makes the chunk quite large. 

The final, correct output for the model is a single Lexsyn with the type S. In general, the output can be thought of as a Lexsyn that contains some number of words and some final syntactic type, where it can no longer combine with any of the other lexsyns. Details on how the Rules utilize the working space in the Sentence chunk will be covered in the next section. 

\subsection{Production Rules}
\subsubsection{Retrieving Syntactic Information}
There are two relevant production rules to begin processing: GrabWord and AddLexSyn. GrabWord is the simple process of retrieving syntactic information about a word in the input. It can fire at any time the retrieval buffer is not busy. This takes a word from the input and makes a retrieval request for a Lexsyn with that word. AddLexSyn then updates the goal state and does cleanup, by removing the word from input and adding the lexsyn to the goal buffer. This presently allows for an infinite working memory span, though the model in principle could work the same by having a fixed working memory span. As of now, however, this could possibly lead to retrieving a set of lexsyns where none could be combined. Both GrabWord and Lexsyn have as many variants as there are maximum number of words in a sentence. 

\subsubsection{Syntactic Rules and Resolutions}
Each Syntactic rule is defined many times, requiring dependencies in the Sentence chunk to be met. Mostly, this is by checking if any Lexsyns in the sentence chunk are matches for each other's dependencies. If it is a match, a retrieval request is put out for the matching type. This sets up another type of production rule to follow where the rule is resolved. This updates the type that's stored in chunk, removes the chunk that's been absorbed (in Composition, for no particular reason, the left always absorbs the right), and removes all other possible types of the new chunk, if they still exist. In other words, on the first combination, each Lexsyn contains multiple types, but after it's been combined and forms a type that's not specific to that word, the other types are removed as they are non-equivalent. The syntactic rules in CCG are described below. 

\begin{itemize}
\item \textit{Forward Application} is a simple combinatory rule where a single dependency of a compound type is resolved to the right (in other words, the type has the Slash combinatory operator). The type resolving the dependency can be a simple type or a compound type. 

\item \textit{Backward Application} is a simple combinatory rule where a single dependency of a compound type is resolved to the left (in other words, the type has the Backslash operator). The type resolving the dependency can be a simple type or a compound type.

\item \textit{Forward Composition} takes two compound types with the Slash operator. If one type has a dependency to the right, and the other type's left side resolves that dependency, then that type gains the other type's right side as a new dependency to the right but resolves its current one and adds that word to the right. 

\item \textit{Backward Composition} takes two compound types with the Backslash operator. If one type has a dependency to the left, and the other type's right side resolves that dependency, then that type gains the other type's left side as a new dependency to the left but resolves its current one and adds that word to the left.  

\item \textit{Begin Conjunction} corresponds to adding a conjunction to a type that could benefit from it. For instance, this would be the process of transforming "walking" to "and walking" or "walking and". 

\item \textit{Finish Conjunction} corresponds to adding an equivalent type to the phrase that contains the conjunction. In other words, it's the processing of transforming "and walking" to "talking and walking" or "walking and" to "walking and talking".
\end{itemize}