package ar.xmlparser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LineParser {
	private final String regex;
	private final Pattern p;
	private final NodeHandler nh;
	
	public LineParser(String regex) {
		this.regex = regex;
		this.p = Pattern.compile(regex);
		nh = new NodeHandler();
	}
	//XML 
	public LineParser() {
		this.regex = "^(?<start><[a-z]+(?<attrs> [a-zA-z:0-9]+=\"[a-zA-Z0-9.'_:\\-\\[\\]]+\")*>)?(?<value>[a-zA-Z0-9?':!+`\\$\\-.,]+)?(?<close></[a-z\\-]+>)?$";
		this.p = Pattern.compile(regex);
		nh = new NodeHandler();
	}
	public boolean parse(String input) throws Exception {
		input = input.trim();				
		Matcher m = p.matcher(input);
		String[] vals = new String[4];
		while (m.find()) {
			vals[0] = m.group("start");
			vals[1] = m.group("attrs");
			vals[2] = m.group("value");
			vals[3] = m.group("close");
		}
		//since attrs repeats, it needs it's own special treatment
		vals[1] = "";
		while (m.find()) {
			vals[1] += m.group("attrs");
			
		}
		
		//sanity check, a node should always be created or closed
		if (!NodeCreationRoutine(vals) && !NodeCloseRoutine(vals)) {
			//there are two options. There's a legitimate error, or it's a special node. So we will discard all "comment" nodes and "format" nodes
			try {
				if (input.charAt(2) != '!' && input.charAt(2) != '?') {
					System.err.println(input);
				}	
			}
			catch (Exception e) {
				System.err.println(input);
			}
			return false;
		}
		return true;
	}
	
	//simply for cleanliness
	private boolean NodeCreationRoutine(String[] vals) {
		if (vals[0] != null) {
			//if attr is null, then vals[0] is the "start" expression we actually care about
			//as defined, start contains the open bracket and the closing bracket to not make the group structure too complicated
			if (vals[1] == null) {
				vals[0] = vals[0].substring(1, vals[0].length()-1); //this will just pull off the brackets
			}
			else {
				vals[0] = vals[0].substring(1, vals[0].length()-1-vals[1].length()); //this will pull off the brackets and attrs 
			}
			XmlNode readingNode = new XmlNode(vals[0], vals[3]);
			if (vals[2] != null) {
				String[] attrs = vals[1].trim().split(" "); //this should be all matches.
				for (String a : attrs) {
					String[] keyVal = a.trim().split("=");
					readingNode.addAttribute(keyVal[0], keyVal[1]);
				}
			}
			if (vals[3] == null) {
				nh.AddOpenNode(readingNode);
			}
			else {
				nh.AddClosedNode(readingNode);
			}
			return true;
		}
		return false;
	}
	
	//simply for cleanliness
	private boolean NodeCloseRoutine(String[] vals) throws Exception {
		//this means we just have an endtag.
		if (vals[0] == null && vals[3] != null) {
			//trimming off the closing slash and the brackets
			nh.CloseNode(vals[3].substring(2, vals[3].length()-1));
			return true;
		}
		return false;
	}
}
