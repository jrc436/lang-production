//package edu.psu.acs.lang.production;
//
//import java.util.ArrayList;
//import java.util.List;
//
//import edu.psu.acs.lang.declarative.CCGOperator;
//import edu.psu.acs.lang.declarative.CCGOperatorEnum;
//import edu.psu.acs.lang.declarative.CCGTypeSlot;
//import edu.psu.acs.lang.declarative.ChunkTypeEnum;
//import edu.psu.acs.lang.declarative.NullValue;
//import edu.psu.acs.lang.declarative.SSlotName;
//import edu.psu.acs.lang.declarative.SSlotNameEnum;
//import edu.psu.acs.lang.declarative.Slot;
//import edu.psu.acs.lang.declarative.SlotVar;
//
///**
// * Generally, forward application is performed with the combinator of the primary type. This forward application is performed with a simple type as the primary type
// * It will be transformed into a regular forward application so that the same resolution rule will apply.
// * This rule wont' be necessary once we implement chunking in multiple lexsyns inside the same sentence.
// * @author jrc
// *
// */
//public class RForwardApplication extends SyntaxRule {
//	public RForwardApplication(int cueNum, int cueTypeNum, int maxTypes, int maxwords) {
//		super(SyntaxRuleType.RForwardApplication, cueNum, cueTypeNum, maxwords, maxTypes);
//		String word = "word";
//		String cuetype = "A"; //this is the part that is resolved in this case
//		String cueLeft = "B"; //this is the part that becomes the new main type
//		//basically, take forward application and swap the role of the sentence and the LS
//		List<Slot> goalPrecond = new ArrayList<Slot>();
//		goalPrecond.add(new Slot(new SSlotName(SSlotNameEnum.FullType), new SlotVar(cuetype)));
//		goalPrecond.add(new Slot(new SSlotName(SSlotNameEnum.LexsynCombo, cueNum, maxwords, cueTypeNum, maxTypes), new CCGOperator(CCGOperatorEnum.Slash)));
//		goalPrecond.add(new Slot(new SSlotName(SSlotNameEnum.LexsynString, cueNum, maxwords), new SlotVar(word)));
//		goalPrecond.add(new Slot(new SSlotName(SSlotNameEnum.LexsynRightType, cueNum, maxwords, cueTypeNum, maxTypes), new SlotVar(cuetype)));
//		goalPrecond.add(new Slot(new SSlotName(SSlotNameEnum.LexsynLeftType, cueNum, maxwords, cueTypeNum, maxTypes), new SlotVar(cueLeft)));
//
//		BufferConditions goal = new BufferConditions(Buffer.goal, ChunkTypeEnum.sentence, goalPrecond);
//		super.conditions.add(goal);
//		super.conditions.add(BufferQueries.checkRetrievalEmpty());
//		
//		List<Slot> effects = new ArrayList<Slot>();
//		effects.add(new Slot(new SSlotName(SSlotNameEnum.FullType), new NullValue()));
//		effects.add(new Slot(new SSlotName(SSlotNameEnum.RightFullType), new NullValue()));
//		effects.add(new Slot(new SSlotName(SSlotNameEnum.LeftFullType), new SlotVar(cueLeft)));
//		//effects.add(new Slot(new SSlotName(SSlotNameEnum.State), new GoalState(GoalStateEnum.RetrievedRule)));
//		effects.addAll(ProductionRule.wipeOut(cueNum, maxwords, maxTypes));
//		super.effects.add(BufferEffects.modifyGoal(effects));
//		
//		List<Slot> retr = new ArrayList<Slot>();
//		retr.add(new Slot(CCGTypeSlot.FullType, new SlotVar(cueLeft)));
//		super.effects.add(BufferEffects.makeRetrieval(ChunkTypeEnum.CCGType, retr));
//		
//		super.outputs.add(new SlotVar(word).toString()+" was added to the left"); //backwords, because it's reverse
//	}
//}
// 
//
//
